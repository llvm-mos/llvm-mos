; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs < %s | FileCheck %s

target datalayout = "e-m:e-p:16:8-p1:8:8-i16:8-i32:8-i64:8-f32:8-f64:8-a:8-Fi8-n8"
target triple = "mos"

%class.Base = type { i32 (...)** }
%class.SubA = type { %class.Base }
%class.SubB = type { %class.Base }

$_ZN4SubA2fnEv = comdat any

$_ZN4SubB2fnEv = comdat any

define void @light_spill(i8 zeroext %sel) {
; CHECK-LABEL: light_spill:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    sta __rc16
; CHECK-NEXT:    lda __rc20
; CHECK-NEXT:    pha
; CHECK-NEXT:    lda __rc16
; CHECK-NEXT:    sta __rc20
; CHECK-NEXT:    ldx #0
; CHECK-NEXT:    lda #2
; CHECK-NEXT:    jsr _Znwt
; CHECK-NEXT:    lda __rc20
; CHECK-NEXT:    beq .LBB0_2
; CHECK-NEXT:  ; %bb.1: ; %select.false
; CHECK-NEXT:    ldx #22
; CHECK-NEXT:    lda #46
; CHECK-NEXT:    jmp .LBB0_3
; CHECK-NEXT:  .LBB0_2:
; CHECK-NEXT:    ldx #4
; CHECK-NEXT:    lda #210
; CHECK-NEXT:  .LBB0_3: ; %select.end
; CHECK-NEXT:    ldy #0
; CHECK-NEXT:    sta (__rc2),y
; CHECK-NEXT:    iny
; CHECK-NEXT:    txa
; CHECK-NEXT:    sta (__rc2),y
; CHECK-NEXT:    lda __rc20
; CHECK-NEXT:    beq .LBB0_5
; CHECK-NEXT:  ; %bb.4: ; %select.false2
; CHECK-NEXT:    ldx #mos16lo(_ZN4SubA2fnEv)
; CHECK-NEXT:    stx __rc18
; CHECK-NEXT:    ldx #mos16hi(_ZN4SubA2fnEv)
; CHECK-NEXT:    jmp .LBB0_6
; CHECK-NEXT:  .LBB0_5:
; CHECK-NEXT:    ldx #mos16lo(_ZN4SubB2fnEv)
; CHECK-NEXT:    stx __rc18
; CHECK-NEXT:    ldx #mos16hi(_ZN4SubB2fnEv)
; CHECK-NEXT:  .LBB0_6: ; %select.end1
; CHECK-NEXT:    stx __rc19
; CHECK-NEXT:    jsr __call_indir
; CHECK-NEXT:    pla
; CHECK-NEXT:    sta __rc20
; CHECK-NEXT:    rts
entry:
  %tobool.not = icmp eq i8 %sel, 0
  %call1 = tail call noalias nonnull i8* @_Znwt(i16 zeroext 2) #6
  %0 = bitcast i8* %call1 to i16*
  %.sink = select i1 %tobool.not, i16 1234, i16 5678
  store i16 %.sink, i16* %0, align 1, !tbaa !2
  %b.0 = bitcast i8* %call1 to %class.Base*
  %1 = select i1 %tobool.not, void (%class.Base*)* bitcast (void (%class.SubB*)* @_ZN4SubB2fnEv to void (%class.Base*)*), void (%class.Base*)* bitcast (void (%class.SubA*)* @_ZN4SubA2fnEv to void (%class.Base*)*)
  tail call void %1(%class.Base* nonnull dereferenceable(2) %b.0)
  ret void
}

; Function Attrs: nobuiltin allocsize(0)
declare dso_local nonnull i8* @_Znwt(i16 zeroext) local_unnamed_addr #1

; Function Attrs: nounwind willreturn mustprogress
define linkonce_odr dso_local void @_ZN4SubA2fnEv(%class.SubA* nonnull dereferenceable(2) %this) unnamed_addr #3 comdat align 2 {
; CHECK-LABEL: _ZN4SubA2fnEv:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rts
entry:
  ret void
}

; Function Attrs: nounwind willreturn mustprogress
define linkonce_odr dso_local void @_ZN4SubB2fnEv(%class.SubB* nonnull dereferenceable(2) %this) unnamed_addr #3 comdat align 2 {
; CHECK-LABEL: _ZN4SubB2fnEv:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    rts
entry:
  ret void
}

attributes #0 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #1 = { nobuiltin allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #2 = { inlinehint nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #3 = { nounwind willreturn mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #4 = { nobuiltin nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #5 = { nounwind willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #6 = { builtin allocsize(0) }
attributes #7 = { nounwind }
attributes #8 = { builtin nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 13.0.0 (https://github.com/beholdnec/llvm-mos.git f825efc51c8502ce670859b915ea18c5bf71eded)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"vtable pointer", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
