//===-- MOSFrameLowering.cpp - MOS Frame Information ----------------------===//
//
// Part of LLVM-MOS, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains the MOS implementation of TargetFrameLowering class.
//
//===----------------------------------------------------------------------===//

#include "MOSFrameLowering.h"

#include "MCTargetDesc/MOSMCTargetDesc.h"
#include "MOS.h"
#include "MOSMachineFunctionInfo.h"
#include "MOSRegisterInfo.h"
#include "MOSSubtarget.h"

#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/BinaryFormat/Dwarf.h"
#include "llvm/CodeGen/GlobalISel/CallLowering.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/PseudoSourceValue.h"
#include "llvm/CodeGen/TargetFrameLowering.h"
#include "llvm/CodeGen/TargetInstrInfo.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCDwarf.h"
#include "llvm/IR/DiagnosticInfo.h"
#include "llvm/Support/ErrorHandling.h"

#define DEBUG_TYPE "mos-framelowering"

using namespace llvm;

/// Emit a DWARF expression that computes a normalized hardware stack address.
/// The 6502 hardware stack is at 0x0100-0x01FF. The S register is physically
/// 8-bit, but some debuggers report it as 16-bit (e.g., MAME reports 0x01FE).
/// This expression normalizes to always produce addresses in 0x0100-0x01FF:
///   result = ((S + Offset) & 0xFF) | 0x0100
static void emitNormalizedHardwareStackExpr(SmallVectorImpl<char> &Expr,
                                             unsigned DwarfS, int8_t Offset) {
  // DW_OP_breg<S> <offset> - S + offset
  Expr.push_back(static_cast<char>(dwarf::DW_OP_breg0 + DwarfS));
  Expr.push_back(static_cast<char>(Offset));

  // DW_OP_const1u 0xFF
  Expr.push_back(static_cast<char>(dwarf::DW_OP_const1u));
  Expr.push_back(static_cast<char>(0xFF));

  // DW_OP_and - keep low byte only
  Expr.push_back(static_cast<char>(dwarf::DW_OP_and));

  // DW_OP_const2u 0x0100 (little-endian: 0x00, 0x01)
  Expr.push_back(static_cast<char>(dwarf::DW_OP_const2u));
  Expr.push_back(static_cast<char>(0x00));
  Expr.push_back(static_cast<char>(0x01));

  // DW_OP_or - force into hardware stack page
  Expr.push_back(static_cast<char>(dwarf::DW_OP_or));
}

MOSFrameLowering::MOSFrameLowering()
    : TargetFrameLowering(StackGrowsDown, /*StackAlignment=*/Align(1),
                          /*LocalAreaOffset=*/0) {}

bool MOSFrameLowering::usesStaticStack(const MachineFunction &MF) const {
  return MF.getSubtarget<MOSSubtarget>().staticStack() &&
         !MF.getFunction().hasOptNone() &&
         MF.getFunction().hasFnAttribute("nonreentrant");
}

bool MOSFrameLowering::assignCalleeSavedSpillSlots(
    MachineFunction &MF, const TargetRegisterInfo *TRI,
    std::vector<CalleeSavedInfo> &CSI) const {
  MachineFrameInfo &MFI = MF.getFrameInfo();
  const auto &MOSFI = *MF.getInfo<MOSFunctionInfo>();

  size_t HardStackRemaining = 4;
  for (CalleeSavedInfo &Info : CSI) {
    // Some CSRs may be rewritten to other zero page locations at
    // MOSStaticStackAlloc time. These don't need to be spilled.
    auto It = MOSFI.CSRZPOffsets.find(Info.getReg());
    if (It != MOSFI.CSRZPOffsets.end()) {
      Info.setTargetSpilled();
      continue;
    }

    // We place the first four CSRs on the hard stack, which we don't
    // explicitly model in PEI.
    if (HardStackRemaining) {
      Info.setTargetSpilled();
      --HardStackRemaining;
    } else {
      Info.setFrameIdx(MFI.CreateSpillStackObject(1, Align()));
    }
  }

  return true;
}

bool MOSFrameLowering::enableShrinkWrapping(const MachineFunction &MF) const {
  // Prologues and epilogues are pretty expensive on the 6502: 16-bit additions,
  // saving/restoring CSRs, the works. Accordingly, it's usually a good idea to
  // do shrink wrapping, as this can make prolog/epilogue execution conditional,
  // with no downside.
  //
  // If we're in an interrupt handler, we'll need to save a number of temporary
  // locations, but the uses of those locations haven't been generated by the
  // time shrink wrapping occurs.  Since there's no way for shrink wrapping to
  // determine which blocks will eventually use those locations, we can't use it
  // in that case.
  return !isISR(MF);
}

bool MOSFrameLowering::spillCalleeSavedRegisters(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MI,
    ArrayRef<CalleeSavedInfo> CSI, const TargetRegisterInfo *TRI) const {
  // CLD remain the first thing in a function, since even setting up the frame
  // can involve arithmetic.
  if (MI != MBB.end() && MI->getOpcode() == MOS::CLD_Implied)
    ++MI;

  MachineIRBuilder Builder(MBB, MI);
  MachineInstrSpan MIS(MI, &MBB);
  const MOSSubtarget &STI = MBB.getParent()->getSubtarget<MOSSubtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const TargetRegisterClass &StackRegClass =
      STI.hasGPRStackRegs() ? MOS::GPRRegClass : MOS::AcRegClass;
  const auto &FuncInfo = MBB.getParent()->getInfo<MOSFunctionInfo>();

  for (const CalleeSavedInfo &CI : CSI) {
    Register Reg = CI.getReg();
    if (FuncInfo->CSRZPOffsets.count(Reg))
      continue;
    if (CI.isTargetSpilled()) {
      if (!StackRegClass.contains(Reg))
        Reg = Builder.buildCopy(&StackRegClass, Reg).getReg(0);
      Builder.buildInstr(MOS::PH, {}, {Reg});
    } else {
      assert(!CI.isSpilledToReg());
      const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(Reg);
      TII.storeRegToStackSlot(MBB, Builder.getInsertPt(), Reg, true,
                              CI.getFrameIdx(), RC, Register{});
    }
  }

  // The frame pointer will be generated after the last frame setup instruction.
  for (auto &MI : make_range(MIS.begin(), MIS.getInitial()))
    MI.setFlag(MachineInstr::FrameSetup);

  return true;
}

template <typename F, typename VisitSet>
static void visitReturnBlocks(MachineBasicBlock *MBB, const F &Func,
                              VisitSet &VisitedBBs) {
  if (!VisitedBBs.insert(MBB).second)
    return;
  if (MBB->isReturnBlock())
    Func(*MBB);

  // Follow branches in BB and look for returns
  for (MachineBasicBlock *Succ : MBB->successors())
    visitReturnBlocks(Succ, Func, VisitedBBs);
}

template <typename F>
static void visitReturnBlocks(MachineBasicBlock *MBB, const F &Func) {
  SmallSet<MachineBasicBlock *, 32> VisitedBBs;
  visitReturnBlocks(MBB, Func, VisitedBBs);
}

bool MOSFrameLowering::restoreCalleeSavedRegisters(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MI,
    MutableArrayRef<CalleeSavedInfo> CSI, const TargetRegisterInfo *TRI) const {
  MachineIRBuilder Builder(MBB, MI);
  const MOSSubtarget &STI = MBB.getParent()->getSubtarget<MOSSubtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const TargetRegisterClass &StackRegClass =
      STI.hasGPRStackRegs() ? MOS::GPRRegClass : MOS::AcRegClass;
  const auto &FuncInfo = MBB.getParent()->getInfo<MOSFunctionInfo>();

  MachineInstrSpan MIS(MI, &MBB);

  for (const CalleeSavedInfo &CI : reverse(CSI)) {
    Register Reg = CI.getReg();
    if (FuncInfo->CSRZPOffsets.count(Reg))
      continue;
    if (CI.isTargetSpilled()) {
      if (!StackRegClass.contains(Reg))
        Reg = Builder.getMRI()->createVirtualRegister(&StackRegClass);
      Builder.buildInstr(MOS::PL, {Reg}, {});
      if (Reg != CI.getReg())
        Builder.buildCopy(Register(CI.getReg()), Reg);
    } else {
      assert(!CI.isSpilledToReg());
      const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(Reg);
      TII.loadRegFromStackSlot(MBB, Builder.getInsertPt(), Reg,
                               CI.getFrameIdx(), RC, Register{});
    }
  }

  // Mark the CSRs as used by the return to ensure Machine Copy Propagation
  // doesn't remove the copies that set them.
  visitReturnBlocks(&MBB, [&CSI](MachineBasicBlock &MBB) {
    assert(MBB.rbegin()->isReturn());
    const auto &FuncInfo = MBB.getParent()->getInfo<MOSFunctionInfo>();
    for (const CalleeSavedInfo &CI : CSI) {
      if (FuncInfo->CSRZPOffsets.count(CI.getReg()))
        continue;
      MBB.rbegin()->addOperand(MachineOperand::CreateReg(
          CI.getReg(), /*isDef=*/false, /*isImp=*/true));
    }
  });

  // Record that the frame pointer is killed by these instructions.
  for (auto &MI : make_range(MIS.begin(), MIS.getInitial()))
    MI.setFlag(MachineInstr::FrameDestroy);

  return true;
}

bool MOSFrameLowering::enableCalleeSaveSkip(const MachineFunction &MF) const {
  assert(MF.getFunction().hasFnAttribute(Attribute::NoReturn) &&
         MF.getFunction().hasFnAttribute(Attribute::NoUnwind) &&
         !MF.getFunction().hasFnAttribute(Attribute::UWTable));
  return true;
}

void MOSFrameLowering::determineCalleeSaves(MachineFunction &MF,
                                            BitVector &SavedRegs,
                                            RegScavenger *RS) const {
  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);

  // If we have a frame pointer, the frame register RS15 needs to be saved as
  // well, since the code that uses it hasn't yet been emitted.
  if (hasFP(MF)) {
    SavedRegs.set(MOS::RC30);
    SavedRegs.set(MOS::RC31);
  }

  if (isISR(MF)) {
    // Accesses to RS8 can occur through the register scavenger, which occurs
    // after PEI. Conservatively assume these are used.
    SavedRegs.set(MOS::RC16);
    SavedRegs.set(MOS::RC17);

    // We need A to save anything else. This may require in turn saving A.
    // Normally, this could be done with __save_A, but for ISRs, that location
    // must also be saved. So we have to save A as a CSR, not through the
    // scavenger. Luckily, due to the register ordering, we're ensured that A
    // is saved before any other register.
    if (!SavedRegs.none())
      SavedRegs.set(MOS::A);

    // We need Y to save anything to the soft stack. Similar reasoning applies
    // to Y.
    if (SavedRegs.size() > 4)
      SavedRegs.set(MOS::Y);
  }
}

void MOSFrameLowering::processFunctionBeforeFrameFinalized(
    MachineFunction &MF, RegScavenger *RS) const {
  MachineFrameInfo &MFI = MF.getFrameInfo();

  // Assign all locals to static stack in non-recursive functions.
  if (usesStaticStack(MF)) {
    int64_t Offset = 0;
    for (int Idx : seq(0, MFI.getObjectIndexEnd())) {
      if (MFI.isDeadObjectIndex(Idx) || MFI.isVariableSizedObjectIndex(Idx) ||
          MFI.getStackID(Idx) != TargetStackID::Default)
        continue;

      MFI.setStackID(Idx, TargetStackID::MosStatic);
      MFI.setObjectOffset(Idx, Offset);
      Offset += MFI.getObjectSize(Idx); // Static stack grows up.
    }
    return;
  }
}

MachineBasicBlock::iterator MOSFrameLowering::eliminateCallFramePseudoInstr(
    MachineFunction &MF, MachineBasicBlock &MBB,
    MachineBasicBlock::iterator MI) const {
  int64_t Offset = MI->getOperand(0).getImm();

  // If we've already reserved the outgoing call frame in the prolog/epilog, the
  // pseudo can be summarily removed.
  if (hasReservedCallFrame(MF) || !Offset)
    return MBB.erase(MI);

  // Increment/decrement the stack pointer to reserve space for the call frame.
  MachineIRBuilder Builder(MBB, MI);
  if (MI->getOpcode() ==
      MF.getSubtarget().getInstrInfo()->getCallFrameSetupOpcode())
    Offset = -Offset;
  offsetSP(Builder, Offset);
  return MBB.erase(MI);
}

void MOSFrameLowering::emitPrologue(MachineFunction &MF,
                                    MachineBasicBlock &MBB) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const TargetRegisterInfo &TRI = *MF.getRegInfo().getTargetRegisterInfo();
  const MCRegisterInfo *MRI = MF.getContext().getRegisterInfo();
  MachineIRBuilder Builder(MBB, MBB.begin());
  DebugLoc DL;

  // Stack pointer adjustments need to occur after the CLD in an interrupt
  // handler or the sum might be incorrect.
  for (MachineInstr &MI : MBB)
    if (MI.getOpcode() == MOS::CLD_Implied)
      Builder.setInsertPt(MBB, std::next(MI.getIterator()));

  int64_t StackSize = MFI.getStackSize();
  // If the interrupted routine is in the middle of decrementing its stack
  // pointer, this routine may observe a stack pointer up to 255 bytes higher
  // than its atomic value.  Accordingly, summarily decrement the SP by a page.
  // Interrupts are rarer than the the routines they interrupt, so they pay the
  // cost of dealing with this atomicity problem.
  if (isISR(MF))
    StackSize += 256;

  if (StackSize)
    offsetSP(Builder, -StackSize);

  // Skip the callee-saved push instructions.
  auto MBBI = std::find_if_not(Builder.getInsertPt(), MBB.end(),
                               [](const MachineInstr &MI) {
                                 return MI.getFlag(MachineInstr::FrameSetup);
                               });

  // Emit CFI for stack adjustment. The CFA is based on the soft stack pointer
  // RS0. After the prologue, CFA = RS0 + StackSize.
  //
  // MOS 65xx has two independent stacks:
  //   1. Hardware stack (S register, 0x0100-0x01FF) - where JSR pushes return addresses
  //   2. Soft stack (RS0) - where local variables and callee-saved registers live
  //
  // The CIE initial frame state says: CFA=S+3, PC=[CFA-2]=[S+1]
  // This is correct at function entry before the prologue.
  //
  // When we change CFA to soft-stack based (RS0+StackSize), we must ALSO
  // emit a DW_CFA_expression for PC, because the return address is still
  // on the HARDWARE stack, not on the soft stack.
  //
  // However, the prologue also pushes callee-saved registers to the hardware
  // stack using PHA instructions (up to 4 CSRs). Each PHA decrements S by 1.
  // So the return address is at S + 1 + HardStackCSRCount, not just S + 1.
  if (StackSize) {
    // Get the DWARF register number for RS0 (soft stack pointer)
    unsigned DwarfSP = MRI->getDwarfRegNum(MOS::RS0, true);
    BuildCFI(MBB, MBBI, DL,
             MCCFIInstruction::cfiDefCfa(nullptr, DwarfSP, StackSize),
             MachineInstr::FrameSetup);

    // Emit RS0 (soft stack pointer) restoration rule.
    // The caller's RS0 = CFA (since we defined CFA = RS0 + StackSize).
    // DW_CFA_val_offset: register's previous value = CFA + offset
    // With offset 0: caller's RS0 = CFA = RS0 + StackSize
    BuildCFI(MBB, MBBI, DL,
             MCCFIInstruction::createValOffset(nullptr, DwarfSP, 0),
             MachineInstr::FrameSetup);

    // Count how many callee-saved registers were pushed to the hardware stack.
    // These are marked as target-spilled but not in CSRZPOffsets.
    const auto &FuncInfo = MF.getInfo<MOSFunctionInfo>();
    unsigned HardStackCSRCount = 0;
    for (const CalleeSavedInfo &CSI : MFI.getCalleeSavedInfo()) {
      if (FuncInfo->CSRZPOffsets.count(CSI.getReg()))
        continue;
      if (CSI.isTargetSpilled())
        ++HardStackCSRCount;
    }

    // Emit DW_CFA_expression to tell the debugger that PC (return address)
    // is on the hardware stack, NOT relative to the soft stack CFA.
    //
    // DW_CFA_expression implies the expression yields an ADDRESS from which
    // the register value is loaded (implicit dereference).
    //
    // We use normalized expressions to handle both 8-bit and 16-bit S values.
    // The expression computes: ((S + offset) & 0xFF) | 0x0100
    // This ensures the result is always in the hardware stack range 0x0100-0x01FF.
    unsigned DwarfPC = MRI->getDwarfRegNum(MOS::PC, true);
    unsigned DwarfS = MRI->getDwarfRegNum(MOS::S, true);
    int8_t PCOffset = 1 + HardStackCSRCount;

    SmallString<16> PcExpr;
    emitNormalizedHardwareStackExpr(PcExpr, DwarfS, PCOffset);
    BuildCFI(MBB, MBBI, DL,
             MCCFIInstruction::createExpression(nullptr, DwarfPC, PcExpr.str()),
             MachineInstr::FrameSetup);

    // Emit DW_CFA_val_expression for S register restoration.
    //
    // The S register is modified by:
    //   1. The JSR that called this function (decrements S by 2)
    //   2. PHA instructions in the prologue (each decrements S by 1)
    //
    // When LLDB unwinds from this frame to the caller, it needs the caller's
    // S value so it can correctly evaluate the caller's PC expression.
    //
    // The caller's S = current S + HardStackCSRCount + 2
    //   - HardStackCSRCount: undo the PHAs in this function's prologue
    //   - 2: undo the JSR that called this function
    //
    // DW_CFA_val_expression means: the previous value of the register
    // IS the result of the expression (not an address to dereference).
    //
    // We use normalized expressions here too - returning a 16-bit 0x01xx value
    // is safe: 16-bit debuggers use it as-is, 8-bit debuggers truncate to low byte.
    {
      int8_t SOffset = HardStackCSRCount + 2;
      SmallString<16> SExpr;
      emitNormalizedHardwareStackExpr(SExpr, DwarfS, SOffset);
      BuildCFI(MBB, MBBI, DL,
               MCCFIInstruction::createValExpression(nullptr, DwarfS,
                                                      SExpr.str()),
               MachineInstr::FrameSetup);
    }
  }

  // Emit CFI for callee-saved registers saved to the soft stack.
  emitCalleeSavedFrameMoves(MBB, MBBI, DL, /*IsPrologue=*/true);

  if (!hasFP(MF))
    return;

  // Set the frame pointer to the stack pointer.
  Builder.setInsertPt(MBB, MBBI);
  Builder.setDebugLoc({});
  Builder.buildCopy(TRI.getFrameRegister(MF), Register(MOS::RS0));

  // Emit CFI to indicate CFA is now based on the frame pointer.
  // After setting FP = SP, CFA = FP + StackSize.
  unsigned DwarfFP = MRI->getDwarfRegNum(TRI.getFrameRegister(MF), true);
  BuildCFI(MBB, std::next(Builder.getInsertPt()), DL,
           MCCFIInstruction::createDefCfaRegister(nullptr, DwarfFP),
           MachineInstr::FrameSetup);
}

void MOSFrameLowering::emitEpilogue(MachineFunction &MF,
                                    MachineBasicBlock &MBB) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const TargetRegisterInfo &TRI = *MF.getRegInfo().getTargetRegisterInfo();
  const MCRegisterInfo *MRI = MF.getContext().getRegisterInfo();
  MachineIRBuilder Builder(MBB, MBB.getFirstTerminator());
  DebugLoc DL;

  // Restore the stack pointer from the frame pointer.
  if (hasFP(MF)) {
    // Skip the callee-saved push instructions.
    auto MBBI = find_if_not(mbb_reverse(MBB.begin(), Builder.getInsertPt()),
                            [](const MachineInstr &MI) {
                              return MI.getFlag(MachineInstr::FrameDestroy);
                            });
    Builder.setInsertPt(MBB, MachineBasicBlock::iterator(MBBI));

    // Set the stack pointer to the frame pointer.
    Builder.buildCopy(MOS::RS0, TRI.getFrameRegister(MF));

    // Emit CFI to switch CFA back to SP-based.
    unsigned DwarfSP = MRI->getDwarfRegNum(MOS::RS0, true);
    int64_t StackSize = MFI.getStackSize();
    if (isISR(MF))
      StackSize += 256;
    BuildCFI(MBB, std::next(Builder.getInsertPt()), DL,
             MCCFIInstruction::cfiDefCfa(nullptr, DwarfSP, StackSize),
             MachineInstr::FrameDestroy);

    Builder.setInsertPt(MBB, MBB.getFirstTerminator());
  }

  // Find insertion point before the terminator for CFI emissions.
  auto MBBI = MBB.getFirstTerminator();

  // Emit CFI for callee-saved register restoration.
  emitCalleeSavedFrameMoves(MBB, MBBI, DL, /*IsPrologue=*/false);

  int64_t StackSize = MFI.getStackSize();

  if (isISR(MF))
    StackSize += 256;

  // If soft stack is used, increase the soft stack pointer SP.
  if (StackSize)
    offsetSP(Builder, StackSize);
}

uint64_t MOSFrameLowering::staticSize(const MachineFrameInfo &MFI) const {
  uint64_t Size = 0;
  for (int Idx : seq(0, MFI.getObjectIndexEnd()))
    if (MFI.getStackID(Idx) == TargetStackID::MosStatic)
      Size += MFI.getObjectSize(Idx);
  return Size;
}

bool MOSFrameLowering::hasFPImpl(const MachineFunction &MF) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  return MFI.isFrameAddressTaken() || MFI.hasVarSizedObjects();
}

void MOSFrameLowering::offsetSP(MachineIRBuilder &Builder,
                                int64_t Offset) const {
  assert(Offset);
  MachineFunction &MF = Builder.getMF();
  const Function &F = MF.getFunction();

  // MOS uses a 16-bit soft stack pointer (RS0), so stack adjustments are
  // limited to 65535 bytes (the range of a 16-bit value). Larger adjustments
  // cannot be represented in a single 16-bit addition.
  // This is a target limitation, not a compiler bug.
  constexpr int64_t MaxOffset = 65535;
  if (Offset < -MaxOffset || Offset > MaxOffset) {
    uint64_t RequestedSize = static_cast<uint64_t>(Offset < 0 ? -Offset : Offset);
    F.getContext().diagnose(DiagnosticInfoStackSize(
        F, RequestedSize, MaxOffset, DS_Error));
    F.getContext().diagnose(DiagnosticInfoUnsupported(
        F,
        "stack frame too large for MOS target: the 16-bit soft stack pointer "
        "can only be adjusted by up to 65535 bytes per function, but this "
        "function requires " +
            Twine(RequestedSize) +
            " bytes. The MOS 6502 has a 64KB address space, so stack frames "
            "this large are not practical. Consider reducing local variable "
            "size, splitting the function, or using heap allocation."));
    return;
  }

  auto Bytes = static_cast<uint16_t>(Offset);
  int64_t LoBytes = Bytes & 0xFF;
  int64_t HiBytes = Bytes >> 8;
  assert(LoBytes || HiBytes);

  Register A = Builder.getMRI()->createVirtualRegister(&MOS::AcRegClass);
  Register P = Builder.getMRI()->createVirtualRegister(&MOS::PcRegClass);
  Builder.buildInstr(MOS::LDCImm)
      .addDef(P, RegState::Undef, MOS::subcarry)
      .addImm(0);
  if (LoBytes) {
    Builder.buildCopy(A, Register(MOS::RC0));
    auto Add = Builder.buildInstr(MOS::ADCImm, {A, P, P}, {A, LoBytes, P});
    Add->getOperand(1).setSubReg(MOS::subcarry);
    Add->getOperand(2).setSubReg(MOS::subv);
    Add->getOperand(5).setSubReg(MOS::subcarry);
    Builder.buildCopy(MOS::RC0, A);
    // Without this, A would have two definitions; the register scavenger does
    // not allow this.
    A = Builder.getMRI()->createVirtualRegister(&MOS::AcRegClass);
  }

  Builder.buildCopy(A, Register(MOS::RC1));
  auto Add = Builder.buildInstr(MOS::ADCImm, {A, P, P}, {A, HiBytes, P});
  Add->getOperand(1).setSubReg(MOS::subcarry);
  Add->getOperand(2).setSubReg(MOS::subv);
  Add->getOperand(5).setSubReg(MOS::subcarry);
  Builder.buildCopy(MOS::RC1, A);
}

bool MOSFrameLowering::isISR(const MachineFunction &MF) const {
  const Function &F = MF.getFunction();
  if (F.hasFnAttribute("no-isr"))
    return false;
  return F.hasFnAttribute("interrupt") ||
         F.hasFnAttribute("interrupt-norecurse");
}

StackOffset MOSFrameLowering::getFrameIndexReference(const MachineFunction &MF,
                                                     int FI,
                                                     Register &FrameReg) const {
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();

  int64_t Offset = MFI.getObjectOffset(FI);

  if (MFI.getStackID(FI) == TargetStackID::Default) {
    // For soft stack variables, offset is relative to the frame pointer.
    // The frame pointer points to the base of the frame, so we need to add
    // the stack size to get the correct offset.
    Offset += MFI.getStackSize();
    FrameReg = TRI->getFrameRegister(MF);
  } else {
    // For static stack and zero-page allocations, use a zero base register.
    // The offset is the absolute address in these cases.
    FrameReg = MOS::NoRegister;
  }

  return StackOffset::getFixed(Offset);
}

void MOSFrameLowering::BuildCFI(MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator MBBI,
                                const DebugLoc &DL,
                                const MCCFIInstruction &CFIInst,
                                MachineInstr::MIFlag Flag) const {
  MachineFunction &MF = *MBB.getParent();
  unsigned CFIIndex = MF.addFrameInst(CFIInst);
  BuildMI(MBB, MBBI, DL,
          MF.getSubtarget().getInstrInfo()->get(TargetOpcode::CFI_INSTRUCTION))
      .addCFIIndex(CFIIndex)
      .setMIFlag(Flag);
}

void MOSFrameLowering::emitCalleeSavedFrameMoves(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
    const DebugLoc &DL, bool IsPrologue) const {
  MachineFunction &MF = *MBB.getParent();
  const MachineFrameInfo &MFI = MF.getFrameInfo();
  const MCRegisterInfo *MRI = MF.getContext().getRegisterInfo();
  const std::vector<CalleeSavedInfo> &CSI = MFI.getCalleeSavedInfo();
  const auto &FuncInfo = MF.getInfo<MOSFunctionInfo>();

  for (const CalleeSavedInfo &I : CSI) {
    // Skip registers saved to zero page or target-spilled to hard stack
    if (FuncInfo->CSRZPOffsets.count(I.getReg()) || I.isTargetSpilled())
      continue;

    // Skip registers saved to static stack - they have absolute addresses,
    // not CFA-relative offsets, so we can't describe them with DWARF CFI.
    if (MFI.getStackID(I.getFrameIdx()) == TargetStackID::MosStatic)
      continue;

    int64_t Offset = MFI.getObjectOffset(I.getFrameIdx());
    MCRegister Reg = I.getReg();
    unsigned DwarfReg = MRI->getDwarfRegNum(Reg, true);

    if (IsPrologue) {
      BuildCFI(MBB, MBBI, DL,
               MCCFIInstruction::createOffset(nullptr, DwarfReg, Offset),
               MachineInstr::FrameSetup);
    } else {
      BuildCFI(MBB, MBBI, DL,
               MCCFIInstruction::createRestore(nullptr, DwarfReg),
               MachineInstr::FrameDestroy);
    }
  }
}
