//===-- MOSInstrPseudos.td - Describe MOS Pseudo-Instrs ---*- tablegen -*-===//
//
// Part of LLVM-MOS, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===---------------------------------------------------------------------===//
//
// This file describes the MOS pseudo-instructions.
//
// Pseudo-instructions allow deferring generation of specific instruction
// sequences from one pass until a later pass. This is useful whenever an early
// pass is required to make a decision that it doesn't have the information
// necessary to do well.
//
//===---------------------------------------------------------------------===//

class MOSPseudo : Instruction {
  let Namespace = "MOS";

  dag OutOperandList = (outs);
  dag InOperandList = (ins);

  let hasSideEffects = false;
  let mayLoad = false;
  let mayStore = false;
  let isPseudo = true;
  let isCodeGenOnly = true;
}

//===---------------------------------------------------------------------===//
// Post RA Pseudos
//===---------------------------------------------------------------------===//
// These pseudoinstructions defer decisionmaking until after register
// allocation. They're used whenever the best instruction sequence to emit
// depends only on the placement of their arguments and the set of live
// registers before and after the pseudo.
//===---------------------------------------------------------------------===//

// Abstracts LDAIdx, LDXIdx, and LDYIdx. This is almost a logical instruction,
// but the "LDX 1234,X" and "LDY 1234,Y" cases aren't natively supported, and
// more than one instruction is required to emit them.
def LDIdx : MOSPseudo {
  dag OutOperandList = (outs GPR:$dst);
  dag InOperandList = (ins i16imm:$addr, XY:$idx);

  let isReMaterializable = true;
  let mayLoad = true;
}

// Loads a boolean value into C, V, ALSB, XLSB, or YLSB.
def LDImm1 : MOSPseudo {
  dag OutOperandList = (outs CV_GPR_LSB:$dst);
  dag InOperandList = (ins i1imm:$val);

  let isAsCheapAsAMove = true;
  let isMoveImm = true;
  let isReMaterializable = true;
}

// Expands to LDImm 0 for GPR or STZImag8 for Imag8.
def LDZ : MOSPseudo {
  let Predicates = [Has65C02];
  dag OutOperandList = (outs GPRImag8:$dst);
  let Pattern = [(set GPRImag8:$dst, 0)];

  let isAsCheapAsAMove = true;
  let isMoveImm = true;
  let isReMaterializable = true;
}

def INC : MOSPseudo {
  dag OutOperandList = (outs GPRImag8:$dst);
  dag InOperandList = (ins GPRImag8:$src);

  let Constraints = "$dst = $src";
  let Pattern = [(set GPRImag8:$dst, (add GPRImag8:$src, 1))];
  let isAdd = true;
}

def DEC : MOSPseudo {
  dag OutOperandList = (outs GPRImag8:$dst);
  dag InOperandList = (ins GPRImag8:$src);

  let Constraints = "$dst = $src";
  let Pattern = [(set GPRImag8:$dst, (sub GPRImag8:$src, 1))];
}

//===---------------------------------------------------------------------===//
// Soft stack
//===---------------------------------------------------------------------===//

// The call-frame pseudoinstructions form a signalling mechanism to pass the
// size of outgoing call frames from calling-convention lowering (in
// IRTranslator) through to the stack frame prolog-epilog insertion. The latter
// examines these pseudoinstructions to find the largest size that an outgoing
// call frame can be, then preallocates that much space to the stack frame if
// possible. This allows these pseudoinstructions to be summarily removed in
// most cases, since we can instead guarantee that a reserved region at the
// bottom of the stack will always have enough free space to set up the
// arguments of any outgoing call.
class MOSCallFramePseudo : MOSPseudo {
  dag InOperandList = (ins i16imm:$bytes, i16imm:$prior);

  let Defs = [RS0];
  let Uses = [RS0];
}

// Call frame setup pseudo.
def ADJCALLSTACKDOWN : MOSCallFramePseudo;

// Call frame destroy pseudo.
def ADJCALLSTACKUP : MOSCallFramePseudo;

// Produces the low byte of the address of the given frame index. Produces a
// carry required by the high byte calculation.
def AddrLostk : MOSPseudo {
  dag OutOperandList = (outs Anyi8:$dst, Cc:$carry, Vc:$deadv);
  dag InOperandList = (ins Imag16:$base, i16imm:$offset);

  let isReMaterializable = true;
}

// Produces the high byte of the address of the given frame index. Accepts the
// carry produced by the low byte calculation.
def AddrHistk : MOSPseudo {
  dag OutOperandList = (outs Anyi8:$dst, Cc:$deadc, Vc:$deadv);
  dag InOperandList = (ins Imag16:$base, i16imm:$offset, Cc:$carry);

  let isReMaterializable = true;
}

// LDStk and STStk require an additional pointer register; if the stack access
// is far, this is used to materialize the necessary pointer. This "wastes" a
// register in common cases, but it's better to use register allocator
// mechanisms to keep a pointer register free than to scramble at the last
// second to scavenge one up.

// Loads a value (1, 8, or 16 bits) from the soft stack. Eliminated once the
// offset from the frame register is known.
def LDStk : MOSPseudo {
  dag OutOperandList = (outs unknown:$dst, Imag16:$scratch);
  dag InOperandList = (ins Imag16:$base, i16imm:$offset);
  let Constraints = "@earlyclobber $scratch";

  let mayLoad = true;
}

// Stores a value (1, 8, or 16 bits) to the soft stack. Eliminated once the
// offset from the frame register is known.
def STStk : MOSPseudo {
  dag OutOperandList = (outs Imag16:$scratch);
  dag InOperandList = (ins unknown:$src, Imag16:$base, i16imm:$fi);
  let Constraints = "@earlyclobber $scratch";

  let mayStore = true;
}

// Pseudos for setting individual bytes of the stack pointer.  The ordering of
// these pseudos is ensured by their implicit arguments: both claim to read and
// write the entire stack pointer. This is true after a fashion; since the
// 16-bit operation is not atomic, the intermediate 16-bit values are important
// too. This allows setting the SP bytes in a specific order to ensure that an
// incorrect SP can never be observed by an interrupt handler.
class MOSSetSPPseudo : MOSPseudo {
  dag OutOperandList = (outs);
  dag InOperandList = (ins GPR:$val);
  let Defs = [RS0];
  let Uses = [RS0];
}

def SetSPLo : MOSSetSPPseudo;
def SetSPHi : MOSSetSPPseudo;

//===---------------------------------------------------------------------===//
// NZ
//===---------------------------------------------------------------------===//

// Version of SBCImag8 that copies the N and Z flags out to virtual registers.
// This bundles the definition and use of N and Z together to maintain the
// invariant that neither can be live across pseudoinstructions. At most one of
// N or Z can be set (the other must be $noreg), since copying N out usually
// clobbers Z, and vice versa.
def SBCNZImag8 : MOSPseudo {
  dag OutOperandList = (outs Ac:$dst, Cc:$carryout, GPR_LSB:$nout, Vc:$vout, GPR_LSB:$zout);
  dag InOperandList = (ins Ac:$l, Imag8:$r, Cc:$carryin);
  let Constraints = "$dst = $l, $carryout = $carryin";
}

// Terminator versions of CMP. Each of these instructions is ensured to stay
// adjacent to the branch that consumes its N or Z value.

def CMPImmTerm : MOSPseudo {
  dag OutOperandList = (outs Cc:$carry);
  dag InOperandList = (ins GPR:$l, i8imm:$r);

  let Defs = [NZ];

  let isCompare = true;
  let isTerminator = true;
}

def CMPImag8Term : MOSPseudo {
  dag OutOperandList = (outs Cc:$carry);
  dag InOperandList = (ins GPR:$l, Imag8:$r);

  let Defs = [NZ];

  let isCompare = true;
  let isTerminator = true;
}

//===---------------------------------------------------------------------===//
// Control flow
//===---------------------------------------------------------------------===//

// Generic BR that can branch on register LSB, C, or V. Branches to $tgt if
// $tst = $val.
def GBR : MOSPseudo {
  dag InOperandList = (ins label:$tgt, CV_GPR_LSB:$tst, i1imm:$val);

  let isBranch = true;
  let isTerminator = true;
}

// Use the diamond control flow pattern to load one of two immediates based on
// the value of a flag. The output must either be to CV_GPR_LSB or GPR.
def SelectImm : MOSPseudo {
  dag OutOperandList = (outs unknown:$dst);
  dag InOperandList = (ins Flag:$tst, i8imm:$true, i8imm:$false);

  let usesCustomInserter = true;
}
